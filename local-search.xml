<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python初级学习（</title>
    <link href="/2024/02/06/python%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/02/06/python%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="python基础学习总结"><a href="#python基础学习总结" class="headerlink" title="python基础学习总结"></a>python基础学习总结</h1><p>未完待续。。。。。。</p><h2 id="一、知识总结"><a href="#一、知识总结" class="headerlink" title="一、知识总结"></a>一、知识总结</h2><p>1.Python使用加号（+）来合并字符串。</p><p>2.在Python 2中，无需将要打印的内容放在括号内。</p><p>3.Python使用两个乘号表示乘方运算。</p><p>4.调用函数str()，它让Python将非字符串值表示为字符串。</p><p>5.在Python 2中，整数除法的结果只包含整数部分，小数部分被删除。</p><p>计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。</p><p>在Python 2中，若要避免这种情况，务必确保至少有一个操作数为浮点数，这样结果也将为浮点数。</p><p>（与C++类似）</p><p>6.Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。</p><p>7.函数range()让Python从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值</p><p>8.列表解析将for循环和创建新元素的代码合并成一行，并自动附加新元素。</p><p>9.要创建数字列表，可使用函数list()将range()的结果直接转换为列表,list1&#x3D;list(range(min,max))</p><p>10.列表切片0-</p><p>11.python 若将列表直接赋值给另一个列表，即list1&#x3D;list2，那么二者内存地址相同，修改list1便是修改list2</p><p>​      若想复制列表可使用切片，即list1&#x3D;list2[:]</p><p>​      切片表示法[:]创建列表的副本。</p><p>12.要检查是否两个条件都为True，可使用关键字and将两个条件测试合而为一；如果每个测试都通过了，整个表达式就为True；如果至少有一个测试没有通过，整个表达式就为False。</p><p>​     关键字or也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个测试。仅当两个测试都没有通过时，使用or的表达式才为False。</p><p>13.要判断特定的值是否已包含在列表中，可使用关键字in。</p><p>​      确定特定的值未包含在列表中,使用关键字not in。</p><p>14.集合类似于列表，但每个元素都必须是独一无二的。</p><p>15.使用函数input()时，Python将用户输入解读为字符串。</p><p>​      如果你使用的是Python 2.7，应使用函数raw_input()来提示用户输入。这个函数与Python 3中的input()一样，也将输入解读为字符串。</p><p>​      Python 2.7也包含函数input()，但它将用户输入解读为Python代码，并尝试运行它们。因此，最好的结果是出现错误，指出Python不明白输入的代码；而最糟的结果是，将运行你原本无意运行的代码。如果你使用的是Python 2.7，请使用raw_input()而不是input()来获取输入。</p><p>16.使用默认值时，在形参列表中必须先列出没有默认值的形参，再列出有默认值的实参。这让Python依然能够正确地解读位置实参。</p><p>17.传递任意数量的实参,形参名前加的的星号让Python创建一个名为形参名的空元组，并将收到的所有值都封装到这个元组中。</p><p>​      如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置实参和关键字实参，再将余下的实参都收集到最后一个形参中。</p><p>18.使用任意数量的关键字实参，形参中的两个星号让Python创建一个名为形参名的空字典，并将收到的所有名称—值对都封装到这个字典中。在这个函数中，可以像访问其他字典那样访问形参名中的名称—值对。</p><p>19.import语句允许在当前运行的程序文件中使用模块中的代码。</p><p>20.根据约定，在Python中，首字母大写的名称指的是类。</p><p>21.对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。</p><p>22.要创建字典并记录其中的键—值对的添加顺序，可使用模块collections中的OrderedDict类。OrderedDict实例的行为几乎与字典相同，区别只在于记录了键—值对的添加顺序。</p><p>​     模块 random 包含以各种方式生成随机数的函数，其中的 randint()返回一个位于指定范围内的整数。</p><p>23.类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。</p><p>24.读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数int()将其转换为整数，或使用函数float()将其转换为浮点数。</p><p>25.Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str()将其转换为字符串格式。</p><p>26.Python标准库中的模块unittest提供了代码测试工具。</p><p>​      方法名必须以test_打头，这样它才会在我们运行test_function.py时自动运行。</p><h2 id="二、函数使用"><a href="#二、函数使用" class="headerlink" title="二、函数使用"></a>二、函数使用</h2><h3 id="（1）字符串方法"><a href="#（1）字符串方法" class="headerlink" title="（1）字符串方法"></a>（1）字符串方法</h3><h4 id="1-title"><a href="#1-title" class="headerlink" title="1.title()"></a>1.title()</h4><p>title()以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。</p><h4 id="2-upper-lower"><a href="#2-upper-lower" class="headerlink" title="2.upper()    lower()"></a>2.upper()    lower()</h4><p>要将字符串改为全部大写或全部小写。</p><p>不会修改存储在变量中的值</p><h4 id="3-lstrip-strip-rstrip"><a href="#3-lstrip-strip-rstrip" class="headerlink" title="3.lstrip()    strip()    rstrip()"></a>3.lstrip()    strip()    rstrip()</h4><p>剔除字符串开头的空白，同时剔除字符串两端的空白,剔除字符串末尾的空白</p><h4 id="4-replace"><a href="#4-replace" class="headerlink" title="4.replace()"></a>4.replace()</h4><p>将字符串中的特定单词都替换为另一个单词。</p><p>str.replace(old,new)</p><h4 id="5-split"><a href="#5-split" class="headerlink" title="5.split()"></a>5.split()</h4><p>方法split()以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。</p><h4 id="6-count"><a href="#6-count" class="headerlink" title="6.count()"></a>6.count()</h4><p>来确定特定的单词或短语在字符串中出现了多少次。</p><h3 id="（2）列表方法"><a href="#（2）列表方法" class="headerlink" title="（2）列表方法"></a>（2）列表方法</h3><h4 id="1-append"><a href="#1-append" class="headerlink" title="1.append()"></a>1.append()</h4><p>将元素附加到列表末尾</p><p>list.append(object)</p><h4 id="2-insert"><a href="#2-insert" class="headerlink" title="2.insert()"></a>2.insert()</h4><p>在列表的任何位置添加新元素,需要指定新元素的索引和值。</p><p>注意此函数返回空值，是直接改变列表，不能直接print(list.insert(index,object))</p><h4 id="3-del"><a href="#3-del" class="headerlink" title="3.del"></a>3.del</h4><p>l可删除任何位置处的列表元素，条件是知道其索引</p><p>del list[index]</p><h4 id="4-pop"><a href="#4-pop" class="headerlink" title="4.pop()"></a>4.pop()</h4><p>可删除列表末尾的元素，并返回删除元素的值。</p><p>list.pop()</p><p>可以使用pop()来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。</p><p>list.pop(index)</p><h4 id="5-remove"><a href="#5-remove" class="headerlink" title="5.remove()"></a>5.remove()</h4><p>有时候，你不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使用方法remove()。</p><p>方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。</p><p>list.remove(object)</p><h4 id="6-sort"><a href="#6-sort" class="headerlink" title="6.sort()"></a>6.sort()</h4><p>对列表进行排序,正序</p><p>还可以按与字母顺序相反的顺序排列列表元素，为此，只需向sort()方法传递参数reverse&#x3D;True</p><p>正序 list.sort()  逆序 list.sort(reverse&#x3D;True)</p><h4 id="7-sorted"><a href="#7-sorted" class="headerlink" title="7.sorted()"></a>7.sorted()</h4><p>函数sorted()让你能够按特定顺序显示列表元素，同时不影响它们在列表中的原始排列顺序。</p><p>正序 sorted(list) 逆序sorted(list,reverse&#x3D;True)</p><h4 id="8-reverse"><a href="#8-reverse" class="headerlink" title="8.reverse()"></a>8.reverse()</h4><p>要反转列表元素的排列顺序，可使用方法reverse()。</p><p>list.reverse()</p><h4 id="9-len"><a href="#9-len" class="headerlink" title="9.len()"></a>9.len()</h4><p>使用函数len()可快速获悉列表的长度。</p><p>len(list)</p><h4 id="10-min-max-sum"><a href="#10-min-max-sum" class="headerlink" title="10.min() max() sum()"></a>10.min() max() sum()</h4><p>找出数字列表的最大值、最小值和总和</p><p>min(list) max(list) sum(list)</p><h3 id="（3）字典方法"><a href="#（3）字典方法" class="headerlink" title="（3）字典方法"></a>（3）字典方法</h3><h4 id="1-del"><a href="#1-del" class="headerlink" title="1.del"></a>1.del</h4><p>使用del语句时，必须指定字典名和要删除的键。</p><p>del dict[key]</p><h4 id="2-items"><a href="#2-items" class="headerlink" title="2.items()"></a>2.items()</h4><p>返回一个键—值对列表。</p><p>dict.items()</p><h4 id="3-keys"><a href="#3-keys" class="headerlink" title="3.keys()"></a>3.keys()</h4><p>提取字典中的所有键</p><p>dict.keys()</p><h4 id="4-values"><a href="#4-values" class="headerlink" title="4.values"></a>4.values</h4><p>它返回一个值列表，而不包含任何键。</p><p>dict.values()</p><h3 id="（4）类方法"><a href="#（4）类方法" class="headerlink" title="（4）类方法"></a>（4）类方法</h3><h4 id="1-方法-init"><a href="#1-方法-init" class="headerlink" title="1.方法__init__()"></a>1.方法__init__()</h4><p>方法__init__()是一个特殊的方法，每当你根据Dog类创建新实例时，Python都会自动运行它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,others</span>):<br></code></pre></td></tr></table></figure><h4 id="2-super"><a href="#2-super" class="headerlink" title="2.super()"></a>2.super()</h4><p>是一个特殊函数，帮助Python将父类和子类关联起来。</p><h3 id="（5）文件方法"><a href="#（5）文件方法" class="headerlink" title="（5）文件方法"></a>（5）文件方法</h3><h4 id="1-open-close"><a href="#1-open-close" class="headerlink" title="1.open() close()"></a>1.open() close()</h4><p>调用open()时提供了两个实参。第一个实参也是要打开的文件的名称；第二个实参（’w’）告诉Python，我们要以写入模式打开这个文件。</p><p>打开文件时，可指定读取模式（’r’）、写入模式（’w’）、附加模式（’a’）或让你能够读取和写入文件的模式（’r+’）。如果你省略了模式实参，Python将以默认的只读模式打开文件。</p><p>如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（’w’）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件。</p><h4 id="2-with"><a href="#2-with" class="headerlink" title="2.with"></a>2.with</h4><h4 id="3-read"><a href="#3-read" class="headerlink" title="3.read()"></a>3.read()</h4><p>read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删</p><p>除多出来的空行，可在print语句中使用rstrip()</p><h4 id="4-readlines"><a href="#4-readlines" class="headerlink" title="4.readlines()"></a>4.readlines()</h4><p>readlines()从文件中读取每一行，并将其存储在一个列表中</p><h4 id="5-write"><a href="#5-write" class="headerlink" title="5.write()"></a>5.write()</h4><p>函数write()不会在你写入的文本末尾添加换行符</p><h4 id="6-pass"><a href="#6-pass" class="headerlink" title="6.pass"></a>6.pass</h4><h4 id="7-json-dump-json-load"><a href="#7-json-dump-json-load" class="headerlink" title="7.json.dump()  json.load()"></a>7.json.dump()  json.load()</h4><p>函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。</p><h3 id="（7）异常方法"><a href="#（7）异常方法" class="headerlink" title="（7）异常方法"></a>（7）异常方法</h3><h4 id="1-try…except…"><a href="#1-try…except…" class="headerlink" title="1.try…except…"></a>1.try…except…</h4><h3 id="（8）测试方法"><a href="#（8）测试方法" class="headerlink" title="（8）测试方法"></a>（8）测试方法</h3><p>assertEqual(a, b)     核实a &#x3D;&#x3D; b</p><p>assertNotEqual(a, b)       核实a !&#x3D; b</p><p>assertTrue(x)    核实x为True</p><p>assertFalse(x)   核实x为False</p><p>assertIn(<em>item</em>, <em>list</em>)    核实<em>item</em>在<em>list</em>中</p><p>assertNotIn(<em>item</em>, <em>list</em>)      核实<em>item</em>不在<em>list</em>中</p><p>你只能在继承unittest.TestCase的类中使用这些方法</p><h3 id="（9）其他方法"><a href="#（9）其他方法" class="headerlink" title="（9）其他方法"></a>（9）其他方法</h3><h4 id="1-input"><a href="#1-input" class="headerlink" title="1.input()"></a>1.input()</h4><p>函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其存储在一个变量中，以方便你使用。</p><p>函数input()接受一个参数：即要向用户显示的提示或说明，让用户知道该如何做。</p><h2 id="三、单词学习"><a href="#三、单词学习" class="headerlink" title="三、单词学习"></a>三、单词学习</h2><p>1.traceback</p><p>2.module</p><p>3.rstrip</p><p>4.apostrophe</p><p>5.syntax</p><p>6.convert</p><p>7.implicitly</p><p>8.concatenate</p><p>9.perl</p><p>10.zen</p><p>11.indentation</p><p>12.dimension</p><p>13.poll</p><p>14.crust</p><p>15.prompt</p><p>16.snip</p><p>17.cuisine</p><p>18.odometer</p><p>19.browser</p><p>20.notation</p><p>21.anonymous</p><p>22.invasion</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>“强网杯-强网先锋-SpeedUp-wp”</title>
    <link href="/2023/12/22/%E2%80%9C%E5%BC%BA%E7%BD%91%E6%9D%AF-%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8B-SpeedUp-wp%E2%80%9D/"/>
    <url>/2023/12/22/%E2%80%9C%E5%BC%BA%E7%BD%91%E6%9D%AF-%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8B-SpeedUp-wp%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目内容：</p><p>Just calculate a factorial。</p><p><strong>Task</strong></p><p>x&#x3D;(pow(2,27))! (二的二十七次方的阶乘)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>  res = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> x:<br>    res += x % <span class="hljs-number">10</span><br>    x //= <span class="hljs-number">10</span><br>  <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p><strong>flag</strong> 为 flag{sha256(f(x))}</p><h2 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h2><p>1.一开始想取巧的，搜了搜发现了求近似阶乘的斯特林公式，嘿不行，求得数需要准确的数字，所以必须要把数字算出来</p><p>2.然后经过一阵搜索，我发现了救赎，那就是gmpy2库中的gmpy2.fac()求阶乘的函数啦，代码这样写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br>n = <span class="hljs-number">134217728</span><br>result = gmpy2.fac(n)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\\2.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(<span class="hljs-built_in">str</span>(result))<br></code></pre></td></tr></table></figure><p>算出来的数据直接900M多。</p><p>3.数据算出来了那就开始把每一位数字相加，但是接近10亿的数字没有一个在线网页工具受得住的，放一个崩一个</p><p>经过搜索，发现Linux可以很好的处理这么大的数据</p><p><a href="https://blog.csdn.net/weixin_42497593/article/details/116585126">linux统计字符串频数,在Linux的命令行中实现字符出现频率统计的方法-CSDN博客</a></p><p>这是参考博客</p><p>我先用强大记事本将文本中的0删去，再依次将1,2,3,4,5,6,7,8,9替换为A,B,C,D,E,F,G,H,I</p><p>将文本传输至Linux虚拟机，执行指令可以得到</p><p>99923066 B<br>99913041 E<br>99908925 H<br>99907349 D<br>99903199 F<br>99901376 I<br>99895867 G<br>99892637 A<br>99884888 C</p><p>然后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlib<br>B=<span class="hljs-number">99923066</span><br>E=<span class="hljs-number">99913041</span><br>H=<span class="hljs-number">99908925</span><br>D=<span class="hljs-number">99907349</span><br>F=<span class="hljs-number">99903199</span><br>I=<span class="hljs-number">99901376</span><br>G=<span class="hljs-number">99895867</span><br>A=<span class="hljs-number">99892637</span><br>C=<span class="hljs-number">99884888</span><br>SUM=A*<span class="hljs-number">1</span>+B*<span class="hljs-number">2</span>+C*<span class="hljs-number">3</span>+D*<span class="hljs-number">4</span>+E*<span class="hljs-number">5</span>+F*<span class="hljs-number">6</span>+G*<span class="hljs-number">7</span>+H*<span class="hljs-number">8</span>+I*<span class="hljs-number">9</span><br><span class="hljs-built_in">print</span>(SUM)<br><span class="hljs-comment"># 创建一个 SHA256 的加密对象</span><br>hash_object = hashlib.sha256()<br><span class="hljs-comment"># 更新加密对象中的信息</span><br>hash_object.update(<span class="hljs-string">b&#x27;4495662081&#x27;</span>)<br><span class="hljs-comment"># 打印加密后的结果</span><br><span class="hljs-built_in">print</span>(hash_object.hexdigest())<br><br></code></pre></td></tr></table></figure><p>得到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">4495662081</span><br>bbdee5c548fddfc76617c562952a3a3b03d423985c095521a8661d248fad3797<br></code></pre></td></tr></table></figure><p>即flag{bbdee5c548fddfc76617c562952a3a3b03d423985c095521a8661d248fad3797}</p>]]></content>
    
    
    
    <tags>
      
      <tag>ctf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“volatility安装和出现的问题及解决方法”</title>
    <link href="/2023/12/10/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/"/>
    <url>/2023/12/10/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="volatility安装和出现的问题及解决方法"><a href="#volatility安装和出现的问题及解决方法" class="headerlink" title="volatility安装和出现的问题及解决方法"></a>volatility安装和出现的问题及解决方法</h1><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>本人不会再md上插图片然后再博客上显示出来，呜呜呜，所以可以去csdn上看看吧~</p><p>我的csdn博客：<a href="https://blog.csdn.net/clotten/article/details/134909943">volatility安装和出现的问题及解决方法-CSDN博客</a></p><h2 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h2><h3 id="（1）下载所需文件并解压"><a href="#（1）下载所需文件并解压" class="headerlink" title="（1）下载所需文件并解压"></a>（1）下载所需文件并解压</h3><p><a href="https://blog.csdn.net/qq_45894840/article/details/129551831">CTF Misc(2)内存取证基础以及原理，覆盖了大部分题型_ctf 内存取证-CSDN博客</a>  </p><p>在此博客按照教程下载所需文件</p><p>先将volatility-master.zip  distorm3-master.zip  hotoloti-master.zip(里面有mimikatz.py)准备好</p><p>再将它们统统解压</p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-33-13.png"></p><h3 id="（2）将mimikatz-py移动至volatility-master-volatility-plugins-目录下"><a href="#（2）将mimikatz-py移动至volatility-master-volatility-plugins-目录下" class="headerlink" title="（2）将mimikatz.py移动至volatility-master&#x2F;volatility&#x2F;plugins&#x2F;目录下"></a>（2）将mimikatz.py移动至volatility-master&#x2F;volatility&#x2F;plugins&#x2F;目录下</h3><p>将hotoloti-master.zip里的mimikatz.py放入volatility-master&#x2F;volatility&#x2F;plugins&#x2F;目录下</p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-35-15.png"></p><h3 id="（3）在解压后的Volatility目录与distorm3目录下进行编译"><a href="#（3）在解压后的Volatility目录与distorm3目录下进行编译" class="headerlink" title="（3）在解压后的Volatility目录与distorm3目录下进行编译"></a>（3）在解压后的Volatility目录与distorm3目录下进行编译</h3><p>在root权限下分别在解压后的Volatility目录与distorm3目录下进行编译</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">python2 setup.py install<br></code></pre></td></tr></table></figure><h2 id="二、安装pip-pip2-setuptools-与相关插件"><a href="#二、安装pip-pip2-setuptools-与相关插件" class="headerlink" title="二、安装pip pip2 setuptools 与相关插件"></a>二、安装pip pip2 setuptools 与相关插件</h2><h3 id="（1）在root权限下安装pip与pip2"><a href="#（1）在root权限下安装pip与pip2" class="headerlink" title="（1）在root权限下安装pip与pip2"></a>（1）在root权限下安装pip与pip2</h3><h4 id="1-安装pip"><a href="#1-安装pip" class="headerlink" title="1.安装pip"></a>1.安装pip</h4><p>在终端输入pip，会询问是否安装pip，一路y下去</p><h4 id="2-安装pip2"><a href="#2-安装pip2" class="headerlink" title="2.安装pip2"></a>2.安装pip2</h4><p><a href="https://blog.csdn.net/m0_45104021/article/details/131014204">解决kali linux pip2与pip3共存_kali pip2-CSDN博客</a></p><p>照着上面一步一步来</p><h3 id="（2）在root权限下安装setuptools"><a href="#（2）在root权限下安装setuptools" class="headerlink" title="（2）在root权限下安装setuptools"></a>（2）在root权限下安装setuptools</h3><p><a href="https://blog.csdn.net/aspnet_lyc/article/details/80111863">pip 安装包时 error: invalid command ‘egg_info’ 解决办法-CSDN博客</a></p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-40-13.png"></p><p>是的，出现**error: invalid command ‘egg_info’**错误时就是setuptools没装</p><h3 id="（3）在root权限下安装相关插件"><a href="#（3）在root权限下安装相关插件" class="headerlink" title="（3）在root权限下安装相关插件"></a>（3）在root权限下安装相关插件</h3><p>插件<br><strong>Distorm3（反编译库）：pip install distorm3<br>Yara（恶意软件分类工具）：pip install yara<br>PyCrypto（加密工具集）：pip install pycrypto<br>PIL（图片处理库）：pip install pillow<br>OpenPyxl（读写excel文件）：pip install openpyxl<br>ujson（JSON解析）：pip install ujson</strong></p><h2 id="三、解决yara库的问题"><a href="#三、解决yara库的问题" class="headerlink" title="三、解决yara库的问题"></a>三、解决yara库的问题</h2><p>终端输入 <strong>vol.py</strong> 发现 （这是yara库的问题）</p><p>参考：（<a href="https://blog.csdn.net/qq_42880719/article/details/117304586">volatility安装、内存取证常见知识点及例题讲解(已进行2.1次更新)_volatility -f memory.raw –profile&#x3D;win7sp1x64 scre-CSDN博客</a>）</p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-10-07.png"></p><p>输入 <strong>pip install yara</strong></p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-17-30.png"></p><p>找到yara路径</p><p><strong>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages</strong> </p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-20-29.png"></p><p>找到libyara.so所在路径</p><p><strong>&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;usr&#x2F;lib&#x2F;</strong></p><p>之后在root终端输入（路径不一样可以对着改一改）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ln -s <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>python2.<span class="hljs-number">7</span><span class="hljs-regexp">/dist-packages/u</span>sr<span class="hljs-regexp">/lib/</span>libyara.so <span class="hljs-regexp">/usr/</span>lib/libyara.so<br></code></pre></td></tr></table></figure><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-22-21.png"></p><h2 id="四、安装construct库并测试"><a href="#四、安装construct库并测试" class="headerlink" title="四、安装construct库并测试"></a>四、安装construct库并测试</h2><p>vol.py后发现还差个construct</p><p><strong>pip install construct</strong>即可</p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-46-22.png"></p><p>之后试一个内存取证的题看看</p><p>把需要分析的内存镜像文件拖入volatility-master文件夹里执行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python2 vol<span class="hljs-selector-class">.py</span> -f Challenge<span class="hljs-selector-class">.raw</span> imageinfo<br></code></pre></td></tr></table></figure><p>  #f：指定分析的内存镜像文件名</p><p>imageinfo是Volatility中用于获取内存镜像信息的命令。它可以用于确定内存镜像的操作系统类型、版本、架构等信息，以及确定应该使用哪个插件进行内存分析</p><p><img src="/%E2%80%9Cvolatility%E5%AE%89%E8%A3%85%E5%92%8C%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E2%80%9D/Snipaste_2023-12-10_14-55-54.png"></p><p>我的内存镜像文件源于</p><p><a href="https://blog.csdn.net/qq_45894840/article/details/129551831">CTF Misc(2)内存取证基础以及原理，覆盖了大部分题型_ctf 内存取证-CSDN博客</a></p><p>你可以照着此博客上的步骤来熟悉volatility</p><h2 id="五、小结"><a href="#五、小结" class="headerlink" title="五、小结"></a>五、小结</h2><p>好耶！折腾三天终于弄好了，嘿嘿。</p><p>如有问题的话可以问一下</p><p>邮箱：<a href="mailto:&#x63;&#108;&#x6f;&#116;&#x74;&#x65;&#110;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x63;&#108;&#x6f;&#116;&#x74;&#x65;&#110;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11.25-Crypto-WP</title>
    <link href="/2023/11/25/11-25-Crypto-WP/"/>
    <url>/2023/11/25/11-25-Crypto-WP/</url>
    
    <content type="html"><![CDATA[<h1 id="2023-11-25-密码WP"><a href="#2023-11-25-密码WP" class="headerlink" title="2023-11-25  密码WP"></a>2023-11-25  密码WP</h1><h4 id="第一题-SWPUCTF-2021-新生赛-crypto8（Uuencode的特征）"><a href="#第一题-SWPUCTF-2021-新生赛-crypto8（Uuencode的特征）" class="headerlink" title="第一题-[SWPUCTF 2021 新生赛]crypto8（Uuencode的特征）"></a>第一题-[SWPUCTF 2021 新生赛]crypto8（Uuencode的特征）</h4><p>73E-30U1&amp;&gt;V-H965S95]I&lt;U]P;W&#x3D;E&lt;GT&#96;</p><p>开始以为是base85，试了老久发现不是。</p><p>看wp才发现Uuencode。</p><p>Uuencode的算法很简单，编码时它将3个字符顺序放入一个 24 位的缓冲区，缺字符的地方补零，然后将缓冲区截断成为 4 个部分，高位在先，每个部分 6 位，用下面的64个字符重新表示：</p><p>“&#96;!”#$%&amp;’()*+,-.&#x2F;0123456789:;&lt;&#x3D;&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_”</p><p>解码时它将4个字符分别转换为4个6位字符后，截取有用的后六位放入一个 24 位的缓冲区，即得3个二进制代码。</p><h4 id="第二题-SWPUCTF-2021-新生赛-crypto7（MD5的特征）"><a href="#第二题-SWPUCTF-2021-新生赛-crypto7（MD5的特征）" class="headerlink" title="第二题-[SWPUCTF 2021 新生赛]crypto7（MD5的特征）"></a>第二题-[SWPUCTF 2021 新生赛]crypto7（MD5的特征）</h4><p>69f7906323b4f7d1e4e972acf4abfbfc</p><p>以为是16进制，看了wp，嘿MD5。</p><p>md5加密后是16位或者32位的字符，由字母和数字组成，字母大小写统一。</p><h4 id="第三题-SWPUCTF-2021-新生赛-ez-rsa（简单rsa，知道p，q，e求d）"><a href="#第三题-SWPUCTF-2021-新生赛-ez-rsa（简单rsa，知道p，q，e求d）" class="headerlink" title="第三题-[SWPUCTF 2021 新生赛]ez_rsa（简单rsa，知道p，q，e求d）"></a>第三题-[SWPUCTF 2021 新生赛]ez_rsa（简单rsa，知道p，q，e求d）</h4><p>p &#x3D; 1325465431<br>q &#x3D; 152317153<br>e &#x3D; 65537<br>计算出d,将d用MD5加密后包裹NSSCTF{}提交</p><p>我们知道这涉及了rsa加密，欧拉函数与乘法逆元（哼啊啊不会</p><ol><li><a href="https://oi-wiki.org/math/number-theory/euler/">欧拉函数（Euler’s totient function）</a></li><li><a href="https://oi-wiki.org/math/number-theory/inverse/">模意义下乘法运算的逆元（Modular Multiplicative Inverse）</a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d= gmpy2.invert(e,phi)<br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br></code></pre></td></tr></table></figure><h4 id="第四题-SWPUCTF-2021-新生赛-crypto2（共模攻击，有两个e）"><a href="#第四题-SWPUCTF-2021-新生赛-crypto2（共模攻击，有两个e）" class="headerlink" title="第四题-[SWPUCTF 2021 新生赛]crypto2（共模攻击，有两个e）"></a>第四题-[SWPUCTF 2021 新生赛]crypto2（共模攻击，有两个e）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><br>flag  = <span class="hljs-string">&#x27;***************&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>m1 = bytes_to_long(<span class="hljs-built_in">bytes</span>(flag.encode()))<br><br><br>n = p*q<br>e1 = getPrime(<span class="hljs-number">32</span>)<br>e2 = getPrime(<span class="hljs-number">32</span>)<br><span class="hljs-built_in">print</span>()<br><br>flag1 = <span class="hljs-built_in">pow</span>(m1,e1,n)<br>flag2 = <span class="hljs-built_in">pow</span>(m1,e2,n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag1= &#x27;</span>+<span class="hljs-built_in">str</span>(flag1))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag2= &#x27;</span>+<span class="hljs-built_in">str</span>(flag2))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;e1= &#x27;</span> +<span class="hljs-built_in">str</span>(e1))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;e2= &#x27;</span>+<span class="hljs-built_in">str</span>(e2))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;n= &#x27;</span>+<span class="hljs-built_in">str</span>(n))<br><br><br><span class="hljs-comment">#flag1= 100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span><br><span class="hljs-comment">#flag2= 86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span><br><span class="hljs-comment">#e1= 3247473589</span><br><span class="hljs-comment">#e2= 3698409173</span><br><span class="hljs-comment">#n= 103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span><br></code></pre></td></tr></table></figure><p>解题如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> same_module<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag1= <span class="hljs-number">100156221476910922393504870369139942732039899485715044553913743347065883159136513788649486841774544271396690778274591792200052614669235485675534653358596366535073802301361391007325520975043321423979924560272762579823233787671688669418622502663507796640233829689484044539829008058686075845762979657345727814280</span><br>flag2= <span class="hljs-number">86203582128388484129915298832227259690596162850520078142152482846864345432564143608324463705492416009896246993950991615005717737886323630334871790740288140033046061512799892371429864110237909925611745163785768204802056985016447086450491884472899152778839120484475953828199840871689380584162839244393022471075</span><br>e1= <span class="hljs-number">3247473589</span><br>e2= <span class="hljs-number">3698409173</span><br>n= <span class="hljs-number">103606706829811720151309965777670519601112877713318435398103278099344725459597221064867089950867125892545997503531556048610968847926307322033117328614701432100084574953706259773711412853364463950703468142791390129671097834871371125741564434710151190962389213898270025272913761067078391308880995594218009110313</span><br><br><br>m = same_module.attack(n, e1, e2, flag1, flag2)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h4 id="第五题-羊城杯-2021-Bigrsa（共享素数，有两个n）"><a href="#第五题-羊城杯-2021-Bigrsa（共享素数，有两个n）" class="headerlink" title="第五题-[羊城杯 2021]Bigrsa（共享素数，有两个n）"></a>第五题-[羊城杯 2021]Bigrsa（共享素数，有两个n）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> *<br><br>n1 = <span class="hljs-number">103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span><br>n2 = <span class="hljs-number">115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span><br><br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br>c = <span class="hljs-built_in">pow</span>(m, e, n1)<br>c = <span class="hljs-built_in">pow</span>(c, e, n2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c = %d&quot;</span> % c)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span><br><span class="hljs-comment">#n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span><br></code></pre></td></tr></table></figure><p>解题如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n1 = <span class="hljs-number">103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061</span><br>n2 = <span class="hljs-number">115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264</span><br><br>q = GCD(n1,n2)<br>p1 = n1 // q<br>p2 = n2 // q<br><br>d1 = inverse(e, (q-<span class="hljs-number">1</span>)*(p1-<span class="hljs-number">1</span>))<br>d2 = inverse(e, (q-<span class="hljs-number">1</span>)*(p2-<span class="hljs-number">1</span>))<br><br><span class="hljs-built_in">print</span>(long_to_bytes(<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">pow</span>(c, d2, n2), d1, n1)))<br></code></pre></td></tr></table></figure><h4 id="第六题-AFCTF-2018-BASE（用代码解决多重base加密问题）"><a href="#第六题-AFCTF-2018-BASE（用代码解决多重base加密问题）" class="headerlink" title="第六题-[AFCTF 2018]BASE（用代码解决多重base加密问题）"></a>第六题-[AFCTF 2018]BASE（用代码解决多重base加密问题）</h4><p>[<a href="https://www.nssctf.cn/problem/932">AFCTF 2018]BASE | NSSCTF</a></p><p>题解如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;E:\cft_questions\\base\\flag_encode.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    data = f.read()<br>    f.close()<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;&#123;&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(data):<br>        <span class="hljs-built_in">print</span>(data)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">try</span>:<br>        data = base64.b16decode(data)<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">try</span>:<br>            data = base64.b32decode(data)<br>        <span class="hljs-keyword">except</span> Exception:<br>            <span class="hljs-keyword">try</span>:<br>                data = base64.b64decode(data)<br>            <span class="hljs-keyword">except</span> Exception:<br>                data = base64.b85decode(data)<br></code></pre></td></tr></table></figure><h3 id="总结：Crypto之路任重道远，不仅需要代码能力还需要数学方面的相关知识，嗯，学吧！"><a href="#总结：Crypto之路任重道远，不仅需要代码能力还需要数学方面的相关知识，嗯，学吧！" class="headerlink" title="总结：Crypto之路任重道远，不仅需要代码能力还需要数学方面的相关知识，嗯，学吧！"></a>总结：Crypto之路任重道远，不仅需要代码能力还需要数学方面的相关知识，嗯，学吧！</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“CTF方向”</title>
    <link href="/2023/11/11/%E2%80%9CCTF%E6%96%B9%E5%90%91%E2%80%9D/"/>
    <url>/2023/11/11/%E2%80%9CCTF%E6%96%B9%E5%90%91%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<p>Crypto<br>CTF（Capture The Flag）是一种网络安全竞赛，其中参与者需要解决各种信息安全挑战，包括密码学。密码学在CTF中是一个广泛涉及的领域，涉及到许多不同类型的加密算法、攻击技术和挑战。</p><p>以下是密码学在CTF中可能涉及的一些主题和概念：</p><p>加密算法：</p><p>对称加密： 参赛者可能需要分析给定的加密算法，识别密钥和加密&#x2F;解密过程。流行的对称加密算法包括AES、DES、和RC4等。<br>非对称加密： 涉及到使用公钥和私钥进行加密和解密。常见的非对称加密算法包括RSA、ECC等。<br>哈希函数： 破解哈希函数，寻找碰撞，或者逆向计算哈希值，是CTF中常见的挑战。MD5、SHA-1、SHA-256等是常见的哈希函数。<br>常见攻击技术：</p><p>密码分析： 分析密码的性质，例如弱密码、常见密码，以及使用密码字典进行暴力破解。<br>差分密码分析： 在密码学中，差分密码分析是一种攻击技术，通过观察明文和密文的差异来推断密钥。<br>侧信道攻击： 利用加密过程中的侧信道信息，例如时钟频率、功耗等，来推断密钥或明文。<br>隐藏信息和隐写术：</p><p>隐写术： 隐写术涉及将信息隐藏在其他媒体中，例如图像、音频或文本文件。参赛者可能需要分析文件以找到隐藏的信息。<br>流密码和伪随机数生成器：</p><p>流密码： 在CTF中，可能会出现基于伪随机数生成器（PRNG）的流密码。参赛者可能需要分析PRNG的弱点或者找到PRNG的种子值。<br>协议分析：</p><p>安全协议： 分析和攻击安全协议，例如TLS&#x2F;SSL。这可能包括POODLE、Heartbleed等漏洞的利用。<br>常见CTF工具：</p><p>CrypTool： 一个密码学学习工具，用于分析和解密各种加密算法。<br>Wireshark： 用于分析网络流量，可能涉及到协议分析的场景。<br>John the Ripper、Hashcat： 用于密码破解的工具。<br>Binwalk： 用于分析二进制文件，可能涉及到隐写术的场景。<br>在CTF比赛中，密码学题目的目标通常是解密给定的密文、找到隐藏的信息、分析加密算法的弱点，或者攻击使用密码保护的系统。解决这些挑战需要参赛者具备密码学知识、分析技能以及创造性的思维。</p><p>Misc<br>CTF（Capture The Flag）比赛中的Miscellaneous（Misc）方向涵盖了各种与计算机安全相关的主题，但不属于具体的密码学、网络安全或二进制分析等明确定义的领域。Miscellaneous挑战通常涉及广泛的主题，包括隐写术、文件分析、编码和解码、网络流量分析、操作系统知识等等。以下是CTF Misc 方向的一些详细介绍：</p><p>隐写术（Steganography）：</p><p>图像隐写术： 隐写术涉及将信息隐藏在其他媒体中，如图像、音频或视频文件。CTF中的Miscellaneous挑战可能要求参与者分析图像以找到隐藏的信息。<br>音频和视频隐写术： 隐写术不仅限于图像，还可能涉及音频和视频文件的分析，寻找隐藏的信息。<br>文件分析：</p><p>文件格式分析： 参赛者可能需要分析给定文件的结构，寻找隐藏在其中的信息。这可能包括二进制文件、文本文件、PDF文件等。<br>元数据分析： 检查文件的元数据（例如创建日期、作者信息）以及其他可能包含隐藏信息的字段。<br>编码和解码（Encoding&#x2F;Decoding）：</p><p>Base64、Hex等编码： 参赛者可能需要解码使用Base64、Hex等编码的字符串，或者编码给定的明文。<br>URL编码： 分析URL编码的字符串，解码其中的特殊字符。<br>网络流量分析：</p><p>Wireshark挑战： 分析捕获的网络流量，找到隐藏的信息、识别协议或解决与网络通信相关的问题。<br>包分析： 分析特定协议的数据包，识别协议字段或找到隐藏的信息。<br>操作系统知识：</p><p>Linux命令行挑战： Misc方向可能包括一些需要使用Linux命令行技能的挑战，例如查找文件、分析日志等。<br>系统漏洞： 一些Miscellaneous挑战可能与操作系统漏洞有关，需要参赛者利用这些漏洞。<br>Web技能：</p><p>Web文件和目录结构： 分析网站的文件和目录结构，查找隐藏的信息或资源。<br>HTTP请求和响应： 分析HTTP请求和响应，识别可能包含信息的字段。<br>其他杂项挑战：</p><p>数学题目： 可能包括一些需要解决数学问题的挑战，例如解方程、找规律等。<br>谜题： 一些挑战可能是谜题，需要一些创造性的思考来解决。<br>总体而言，Miscellaneous方向涉及到多个计算机安全领域，需要参赛者具备广泛的技能和知识，同时培养一种创造性和灵活性的思维方式。 Misc挑战常常要求参赛者不仅能够深入理解特定领域的知识，还需要跨领域应用这些知识解决问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
